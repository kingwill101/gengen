import 'package:gengen/fs.dart';
import 'package:gengen/module/version_constraint.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

/// Represents a locked/resolved module version
class LockedModule {
  final String path;
  final String version;
  final String resolved;
  final String? sha;
  final DateTime? lockedAt;

  const LockedModule({
    required this.path,
    required this.version,
    required this.resolved,
    this.sha,
    this.lockedAt,
  });

  factory LockedModule.fromJson(String path, Map<String, dynamic> data) {
    return LockedModule(
      path: path,
      version: data['version'] as String? ?? '',
      resolved: data['resolved'] as String? ?? '',
      sha: data['sha'] as String?,
      lockedAt: data['locked_at'] != null
          ? DateTime.tryParse(data['locked_at'] as String)
          : null,
    );
  }

  Map<String, dynamic> toJson() => {
    'version': version,
    'resolved': resolved,
    if (sha != null) 'sha': sha,
    if (lockedAt != null) 'locked_at': lockedAt!.toIso8601String(),
  };

  /// Parse version as semver if possible
  Version? get parsedVersion => Version.tryParse(version);
}

/// Manages the gengen.lock file for reproducible builds
class ModuleLockfile {
  final String lockfilePath;
  final Map<String, LockedModule> _packages;

  ModuleLockfile({
    required this.lockfilePath,
    Map<String, LockedModule>? packages,
  }) : _packages = packages ?? {};

  /// Load lockfile from disk
  factory ModuleLockfile.load(String siteRoot) {
    final lockfilePath = p.join(siteRoot, 'gengen.lock');
    final file = fs.file(lockfilePath);

    if (!file.existsSync()) {
      return ModuleLockfile(lockfilePath: lockfilePath);
    }

    try {
      final content = file.readAsStringSync();
      final yaml = loadYaml(content) as YamlMap?;

      if (yaml == null) {
        return ModuleLockfile(lockfilePath: lockfilePath);
      }

      final packages = <String, LockedModule>{};
      final packagesYaml = yaml['packages'] as YamlMap?;

      if (packagesYaml != null) {
        for (final entry in packagesYaml.entries) {
          final path = entry.key as String;
          final data = Map<String, dynamic>.from(entry.value as YamlMap);
          packages[path] = LockedModule.fromJson(path, data);
        }
      }

      return ModuleLockfile(lockfilePath: lockfilePath, packages: packages);
    } catch (_) {
      return ModuleLockfile(lockfilePath: lockfilePath);
    }
  }

  /// Get all locked packages
  Map<String, LockedModule> get packages => Map.unmodifiable(_packages);

  /// Get a specific locked module
  LockedModule? getPackage(String path) => _packages[path];

  /// Check if a module is locked
  bool hasPackage(String path) => _packages.containsKey(path);

  /// Add or update a locked module
  void setPackage(String path, LockedModule module) {
    _packages[path] = module;
  }

  /// Remove a locked module
  void removePackage(String path) {
    _packages.remove(path);
  }

  /// Clear all locked packages
  void clear() {
    _packages.clear();
  }

  /// Save lockfile to disk
  void save() {
    final buffer = StringBuffer();
    buffer.writeln('# Auto-generated by gengen - do not edit');
    buffer.writeln('# Run "gengen mod get" to update');
    buffer.writeln();
    buffer.writeln('packages:');

    // Sort packages for deterministic output
    final sortedPaths = _packages.keys.toList()..sort();

    for (final path in sortedPaths) {
      final module = _packages[path]!;
      buffer.writeln('  "$path":');
      buffer.writeln('    version: "${module.version}"');
      buffer.writeln('    resolved: "${module.resolved}"');
      if (module.sha != null) {
        buffer.writeln('    sha: "${module.sha}"');
      }
      if (module.lockedAt != null) {
        buffer.writeln(
          '    locked_at: "${module.lockedAt!.toIso8601String()}"',
        );
      }
    }

    fs.file(lockfilePath).writeAsStringSync(buffer.toString());
  }

  /// Check if lockfile exists
  bool get exists => fs.file(lockfilePath).existsSync();

  /// Check if lockfile is empty
  bool get isEmpty => _packages.isEmpty;
}
